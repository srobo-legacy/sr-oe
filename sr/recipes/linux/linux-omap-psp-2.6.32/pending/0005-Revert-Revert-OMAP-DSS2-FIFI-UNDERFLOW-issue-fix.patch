From a107c9c4bd642fd5044275ffcb00a8e20da481c7 Mon Sep 17 00:00:00 2001
From: Vaibhav Hiremath <hvaibhav@ti.com>
Date: Tue, 10 Aug 2010 20:05:51 +0530
Subject: [PATCH 5/9] Revert "Revert "OMAP: DSS2: FIFI UNDERFLOW issue fixed""

This reverts commit b2c74dc43741d8d824e5439f6a82c0a5aa5d1c80.

There was small bug in the GFX UNDERFLOW patch, so I had reverted it and now
since I have fix for the same so I am again commiting the fix which reverts the
original patch with fix.

Original commit - 4b58d194fd8f5a1c68803eb326e9a71621571696.
Revert commit - b2c74dc43741d8d824e5439f6a82c0a5aa5d1c80
---
 drivers/video/omap2/omapfb/omapfb-main.c |   83 ++++++++++++++++++++----------
 1 files changed, 55 insertions(+), 28 deletions(-)

diff --git a/drivers/video/omap2/omapfb/omapfb-main.c b/drivers/video/omap2/omapfb/omapfb-main.c
index ef29983..7f47a34 100644
--- a/drivers/video/omap2/omapfb/omapfb-main.c
+++ b/drivers/video/omap2/omapfb/omapfb-main.c
@@ -182,6 +182,11 @@ static unsigned omapfb_get_vrfb_offset(struct omapfb_info *ofbi, int rot)
 static u32 omapfb_get_region_rot_paddr(struct omapfb_info *ofbi, int rot)
 {
 	if (ofbi->rotation_type == OMAP_DSS_ROT_VRFB) {
+		if (rot == FB_ROTATE_CW)
+			rot = FB_ROTATE_CCW;
+		else if (rot == FB_ROTATE_CCW)
+			rot = FB_ROTATE_CW;
+
 		return ofbi->region.vrfb.paddr[rot]
 			+ omapfb_get_vrfb_offset(ofbi, rot);
 	} else {
@@ -189,20 +194,32 @@ static u32 omapfb_get_region_rot_paddr(struct omapfb_info *ofbi, int rot)
 	}
 }
 
-static u32 omapfb_get_region_paddr(struct omapfb_info *ofbi)
+static u32 omapfb_get_region_paddr(struct omapfb_info *ofbi, int rot)
 {
-	if (ofbi->rotation_type == OMAP_DSS_ROT_VRFB)
-		return ofbi->region.vrfb.paddr[0];
-	else
+	if (ofbi->rotation_type == OMAP_DSS_ROT_VRFB) {
+		if (rot == FB_ROTATE_CW)
+			rot = FB_ROTATE_CCW;
+		else if (rot == FB_ROTATE_CCW)
+			rot = FB_ROTATE_CW;
+
+		return ofbi->region.vrfb.paddr[rot];
+	} else {
 		return ofbi->region.paddr;
+	}
 }
 
-static void __iomem *omapfb_get_region_vaddr(struct omapfb_info *ofbi)
+static void __iomem *omapfb_get_region_vaddr(struct omapfb_info *ofbi, int rot)
 {
-	if (ofbi->rotation_type == OMAP_DSS_ROT_VRFB)
-		return ofbi->region.vrfb.vaddr[0];
-	else
+	if (ofbi->rotation_type == OMAP_DSS_ROT_VRFB) {
+		if (rot == FB_ROTATE_CW)
+			rot = FB_ROTATE_CCW;
+		else if (rot == FB_ROTATE_CCW)
+			rot = FB_ROTATE_CW;
+
+		return ofbi->region.vrfb.vaddr[rot];
+	} else {
 		return ofbi->region.vaddr;
+	}
 }
 
 static struct omapfb_colormode omapfb_colormodes[] = {
@@ -501,7 +518,7 @@ static int setup_vrfb_rotation(struct fb_info *fbi)
 	unsigned bytespp;
 	bool yuv_mode;
 	enum omap_color_mode mode;
-	int r;
+	int r, rotation = var->rotate;
 	bool reconf;
 
 	if (!rg->size || ofbi->rotation_type != OMAP_DSS_ROT_VRFB)
@@ -509,6 +526,11 @@ static int setup_vrfb_rotation(struct fb_info *fbi)
 
 	DBG("setup_vrfb_rotation\n");
 
+	if (rotation == FB_ROTATE_CW)
+		rotation = FB_ROTATE_CCW;
+	else if (rotation == FB_ROTATE_CCW)
+		rotation = FB_ROTATE_CW;
+
 	r = fb_mode_to_dss_mode(var, &mode);
 	if (r)
 		return r;
@@ -532,32 +554,35 @@ static int setup_vrfb_rotation(struct fb_info *fbi)
 			vrfb->yres != var->yres_virtual)
 		reconf = true;
 
-	if (vrfb->vaddr[0] && reconf) {
+	if (vrfb->vaddr[rotation] && reconf) {
 		fbi->screen_base = NULL;
 		fix->smem_start = 0;
 		fix->smem_len = 0;
-		iounmap(vrfb->vaddr[0]);
-		vrfb->vaddr[0] = NULL;
+		iounmap(vrfb->vaddr[rotation]);
+		vrfb->vaddr[rotation] = NULL;
 		DBG("setup_vrfb_rotation: reset fb\n");
 	}
 
-	if (vrfb->vaddr[0])
+	if (vrfb->vaddr[rotation])
 		return 0;
 
-	omap_vrfb_setup(&rg->vrfb, rg->paddr,
-			var->xres_virtual,
-			var->yres_virtual,
-			bytespp, yuv_mode);
+	if (rotation == FB_ROTATE_CW || rotation == FB_ROTATE_CCW)
+		omap_vrfb_setup(&rg->vrfb, rg->paddr,
+				var->yres_virtual, var->xres_virtual,
+				bytespp, yuv_mode);
+	else
+		omap_vrfb_setup(&rg->vrfb, rg->paddr,
+				var->xres_virtual, var->yres_virtual,
+				bytespp, yuv_mode);
 
-	/* Now one can ioremap the 0 angle view */
-	r = omap_vrfb_map_angle(vrfb, var->yres_virtual, 0);
+	/* Now one can ioremap the rotation angle view */
+	r = omap_vrfb_map_angle(vrfb, var->yres_virtual, rotation);
 	if (r)
 		return r;
-
 	/* used by open/write in fbmem.c */
-	fbi->screen_base = ofbi->region.vrfb.vaddr[0];
+	fbi->screen_base = ofbi->region.vrfb.vaddr[rotation];
 
-	fix->smem_start = ofbi->region.vrfb.paddr[0];
+	fix->smem_start = ofbi->region.vrfb.paddr[rotation];
 
 	switch (var->nonstd) {
 	case OMAPFB_COLOR_YUV422:
@@ -601,7 +626,8 @@ void set_fb_fix(struct fb_info *fbi)
 	DBG("set_fb_fix\n");
 
 	/* used by open/write in fbmem.c */
-	fbi->screen_base = (char __iomem *)omapfb_get_region_vaddr(ofbi);
+	fbi->screen_base = (char __iomem *)omapfb_get_region_vaddr(ofbi,
+			var->rotate);
 
 	/* used by mmap in fbmem.c */
 	if (ofbi->rotation_type == OMAP_DSS_ROT_VRFB) {
@@ -624,7 +650,7 @@ void set_fb_fix(struct fb_info *fbi)
 		fix->smem_len = rg->size;
 	}
 
-	fix->smem_start = omapfb_get_region_paddr(ofbi);
+	fix->smem_start = omapfb_get_region_paddr(ofbi, var->rotate);
 
 	fix->type = FB_TYPE_PACKED_PIXELS;
 
@@ -860,11 +886,11 @@ static int omapfb_setup_overlay(struct fb_info *fbi, struct omap_overlay *ovl,
 
 
 	if (ofbi->rotation_type == OMAP_DSS_ROT_VRFB) {
-		data_start_p = omapfb_get_region_rot_paddr(ofbi, rotation);
+		data_start_p = omapfb_get_region_rot_paddr(ofbi, 0);
 		data_start_v = NULL;
 	} else {
-		data_start_p = omapfb_get_region_paddr(ofbi);
-		data_start_v = omapfb_get_region_vaddr(ofbi);
+		data_start_p = omapfb_get_region_paddr(ofbi, 0);
+		data_start_v = omapfb_get_region_vaddr(ofbi, 0);
 	}
 
 	if (ofbi->rotation_type == OMAP_DSS_ROT_VRFB)
@@ -1076,6 +1102,7 @@ static struct vm_operations_struct mmap_user_ops = {
 static int omapfb_mmap(struct fb_info *fbi, struct vm_area_struct *vma)
 {
 	struct omapfb_info *ofbi = FB2OFB(fbi);
+	struct fb_var_screeninfo *var = &fbi->var;
 	struct fb_fix_screeninfo *fix = &fbi->fix;
 	unsigned long off;
 	unsigned long start;
@@ -1087,7 +1114,7 @@ static int omapfb_mmap(struct fb_info *fbi, struct vm_area_struct *vma)
 		return -EINVAL;
 	off = vma->vm_pgoff << PAGE_SHIFT;
 
-	start = omapfb_get_region_paddr(ofbi);
+	start = omapfb_get_region_paddr(ofbi, var->rotate);
 	len = fix->smem_len;
 	if (off >= len)
 		return -EINVAL;
-- 
1.6.2.4


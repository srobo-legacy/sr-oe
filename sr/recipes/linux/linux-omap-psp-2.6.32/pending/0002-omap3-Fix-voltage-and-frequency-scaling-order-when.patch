From d247a112a9ffbad1057a2c8bede5727940ac2045 Mon Sep 17 00:00:00 2001
From: Ranjith Lohithakshan <ranjithl@ti.com>
Date: Fri, 28 May 2010 15:20:32 +0530
Subject: [PATCH 2/9] omap3: Fix voltage and frequency scaling order when changing OPP via mpurate

When lowering an OPP via mpurate from what is being set by bootloader,
the frequency need to be lowered before voltage is ramped down. The
current code was not taking this into consideration and was always
adjusting the voltage before the frequency adjustments.

This was leading to crashes on 3730 when mpurate was set to 300MHz
because the voltage was lowered before the frequency.

This patch fixes these issues by tracking the direction of OPP change
and doing the voltage and frequency change in the right order.

Signed-off-by: Ranjith Lohithakshan <ranjithl@ti.com>
---
 arch/arm/mach-omap2/clock34xx.c   |   51 +++++++++++++++++++++++-------------
 arch/arm/mach-omap2/smartreflex.c |   11 +++++---
 2 files changed, 39 insertions(+), 23 deletions(-)

diff --git a/arch/arm/mach-omap2/clock34xx.c b/arch/arm/mach-omap2/clock34xx.c
index 2bb7182..dd408eb 100644
--- a/arch/arm/mach-omap2/clock34xx.c
+++ b/arch/arm/mach-omap2/clock34xx.c
@@ -65,6 +65,7 @@ struct clk *sdrc_ick_p, *arm_fck_p;
  */
 unsigned int vdd1_opp = 0;
 unsigned int vdd2_opp = 0;
+bool vdd_scale_down = false;
 
 /**
  * omap3430es2_clk_ssi_find_idlest - return CM_IDLEST info for SSI
@@ -429,6 +430,24 @@ static void __init omap2_clk_iva_init_to_idle(void)
 
 }
 
+static u16 get_opp(struct omap_opp *opp_freq_table,
+					unsigned long freq)
+{
+	struct omap_opp *prcm_config;
+
+	prcm_config = opp_freq_table;
+
+	if (prcm_config->rate <= freq)
+		return prcm_config->opp_id; /* Return the Highest OPP */
+	for (; prcm_config->rate; prcm_config--)
+		if (prcm_config->rate < freq)
+			return (prcm_config+1)->opp_id;
+		else if (prcm_config->rate == freq)
+			return prcm_config->opp_id;
+	/* Return the least OPP */
+	return (prcm_config+1)->opp_id;
+}
+
 /* REVISIT: Move this init stuff out into clock.c */
 
 /*
@@ -444,8 +463,10 @@ static void __init omap2_clk_iva_init_to_idle(void)
  */
 static int __init omap2_clk_arch_init(void)
 {
-	struct omap_opp *opp_table;
-	short valid=0, err=0, i;
+	short err=0;
+	u16	current_vdd1_opp;
+	struct clk *arm_fck;
+	unsigned long current_mpu_rate;
 
 	if (!mpurate)
 		return -EINVAL;
@@ -463,6 +484,10 @@ static int __init omap2_clk_arch_init(void)
 	if (WARN((!l3_opps), "OPP table not defined for L3\n"))
 		err = 1;
 
+	arm_fck = clk_get(NULL, "arm_fck");
+	if (WARN(IS_ERR(arm_fck), "Failed to get arm_fck.\n"))
+		err = 1;
+
 	if (err)
 		return -ENOENT;
 
@@ -475,24 +500,12 @@ static int __init omap2_clk_arch_init(void)
 		pr_err("This silicon doesn't support 720MHz\n");
 	}
 
-	/*
-	 * Select VDD1 OPP corresponding to mpurate
-	 */
-	opp_table = mpu_opps;
-
-	for (i = 1; opp_table[i].opp_id <= get_max_vdd1(); i++) {
-		if (opp_table[i].rate == mpurate) {
-			valid = 1;
-			break;
-		}
-	}
+	current_mpu_rate = clk_get_rate(arm_fck);
+	current_vdd1_opp = get_opp(mpu_opps + get_max_vdd1(), current_mpu_rate);
+	vdd1_opp = get_opp(mpu_opps + get_max_vdd1(), mpurate);
 
-	if (valid) {
-		vdd1_opp = opp_table[i].opp_id;
-	} else {
-		pr_err("Invalid MPU rate (%u)\n", mpurate);
-		return -EINVAL;
-	}
+	if (vdd1_opp < current_vdd1_opp)
+		vdd_scale_down = true;
 
 	/*
 	 * Match lowest OPP setting for VDD1 with lowest OPP for VDD2 as well.
diff --git a/arch/arm/mach-omap2/smartreflex.c b/arch/arm/mach-omap2/smartreflex.c
index 3b6ddf8..fd34af2 100644
--- a/arch/arm/mach-omap2/smartreflex.c
+++ b/arch/arm/mach-omap2/smartreflex.c
@@ -48,6 +48,7 @@
  */
 extern unsigned int vdd1_opp;
 extern unsigned int vdd2_opp;
+extern bool vdd_scale_down;
 
 extern int __init omap2_clk_set_freq(void);
 
@@ -1082,6 +1083,10 @@ static int __init omap3_sr_init(void)
 	sr_set_clk_length(&sr1);
 	sr_set_clk_length(&sr2);
 
+	/* For OPP scale down, scale down frequency before voltage */
+	if (cpu_is_omap34xx() && vdd_scale_down)
+        omap2_clk_set_freq();
+
 	/* Call the VPConfig, VCConfig, set N Values. */
 	sr_set_nvalues(&sr1);
 	sr_configure_vp(SR1);
@@ -1089,10 +1094,8 @@ static int __init omap3_sr_init(void)
 	sr_set_nvalues(&sr2);
 	sr_configure_vp(SR2);
 
-	/*
-	 * With voltages matching target OPP, set corresponding frequency.
-	 */
-	if (cpu_is_omap34xx())
+	/* For OPP scale up, scale up the frequency after voltage */
+	if (cpu_is_omap34xx() && !vdd_scale_down)
 		omap2_clk_set_freq();
 
 	ret = sysfs_create_file(power_kobj, &sr_vdd1_autocomp.attr);
-- 
1.6.2.4

